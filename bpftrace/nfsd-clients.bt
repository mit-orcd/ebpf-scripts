#!/usr/bin/env -S bpftrace -q

// This script assumes NFSv4!
// For NFSv3, you would need to attach to the nfsd_dispatch function which has
// a much simpler data presentation, as data is not bundled into compound
// packets as it is in NFSv4

struct nfsd4_compoundres {
    u64 xdr;
    u64 rqstp;
};

struct nfsd4_op {
    u32 opnum;
};

kprobe:nfsd4_encode_operation {
    $res = (struct nfsd4_compoundres *)arg0;
    $op = (struct nfsd4_op *)arg1;

    // Pointer to the request struct
    $rqstp = (struct svc_rqst *)$res->rqstp;

    // Get the UID from the request struct
    $uid = $rqstp->rq_cred.cr_uid.val;

    // Get the sockaddr pointer
    $addr_ptr = (uint64)$rqstp + offsetof(struct svc_rqst, rq_addr);
    $sa = (struct sockaddr *)$addr_ptr;

    // Print the IP address, works for v4 or v6
    if ($sa->sa_family == 2) {  // AF_INET (IPv4)
        $sin = (struct sockaddr_in *)$addr_ptr;

        @ip4[$uid,$sin->sin_addr.s_addr,0] = count();

    } else if ($sa->sa_family == 10) {  // AF_INET6 (IPv6)
        $sin6 = (struct sockaddr_in6 *)$addr_ptr;

        $w0 = bswap($sin6->sin6_addr.in6_u.u6_addr32[0]);
        $w1 = bswap($sin6->sin6_addr.in6_u.u6_addr32[1]);
        $w2 = bswap($sin6->sin6_addr.in6_u.u6_addr32[2]);
        $w3 = bswap($sin6->sin6_addr.in6_u.u6_addr32[3]);
        $hi = ($w0 << 32) | $w1;
        $lo = ($w2 << 32) | $w3;
        @ip6[$uid, $hi, $lo] = count();
    }
}

interval:s:10 { exit(); }
